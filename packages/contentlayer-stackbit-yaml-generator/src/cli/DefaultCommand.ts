import type { HasCwd } from '@contentlayer/core'
import * as core from '@contentlayer/core'
import { provideJaegerTracing, recRemoveUndefinedValues } from '@contentlayer/utils'
import type { HasConsole } from '@contentlayer/utils/effect'
import { OT, pipe, pretty, provideConsole, S, T } from '@contentlayer/utils/effect'
import { Command, Option } from 'clipanion'
import { promises as fs } from 'node:fs'
import * as path from 'node:path'
import * as t from 'typanion'

import type { Transform } from '../lib/index.js'
import { convertSchema } from './convert.js'
import { toYamlString } from './utils.js'

const defaultStackbitYamlPath = () => `${path.join(process.cwd())}/stackbit.yaml`
const defaultTransformPath = () => `${path.join(process.cwd())}/contentlayer-stackbit-yaml-generator.js`

export class DefaultCommand extends Command {
  configPath = Option.String('-c,--config', 'contentlayer.config.ts', {
    description: 'Path to the Contentlayer config',
    validator: t.isString(),
  })

  stackbitYamlPath = Option.String('-s,--stackbit', defaultStackbitYamlPath(), {
    description: 'Target path for Stackbit YAML file',
    validator: t.isString(),
  })

  transformPath = Option.String('-t,--transform', defaultTransformPath(), {
    description:
      'Path to a "transform file" which allows you to transform the derived Stackbit config before generating the output file',
    validator: t.isString(),
  })

  watch = Option.Boolean('-w,--watch', false, {
    description: 'Watch the config file for changes and regenerate the output file',
  })

  // TODO refactor similar to `@contentlayer/cli`
  async execute() {
    try {
      await pipe(
        this.executeSafe(),
        provideJaegerTracing('contentlayer-stackbit-yaml-generator'),
        T.tapCause((cause) => T.die(pretty(cause))),
        core.provideCwd,
        provideConsole,
        T.runPromise,
      )
    } catch (e: any) {
      console.error(e)
      throw e
    }
  }

  executeSafe = (): T.Effect<OT.HasTracer & HasCwd & HasConsole, unknown, void> =>
    this.watch
      ? pipe(
          core.getConfigWatch({ configPath: this.configPath }),
          S.mapEffectEitherRight((config) => pipe(transformAndGenerateStackbitYaml({ config, self: this }), T.either)),
          S.runDrain,
        )
      : pipe(
          core.getConfig({ configPath: this.configPath }),
          T.chain((config) => transformAndGenerateStackbitYaml({ config, self: this })),
          OT.withSpan('DefaultCommand:executeSafe'),
        )
}

const transformAndGenerateStackbitYaml = ({ config, self }: { config: core.Config; self: DefaultCommand }) =>
  pipe(
    T.struct({
      source: T.succeed(config.source),
      schema: config.source.provideSchema({ esbuildHash: config.esbuildHash, extensionProperties: ['stackbit'] }),
    }),

    T.chain(({ schema, source }) =>
      T.tryCatchPromise(
        async () => {
          let stackbitConfig = convertSchema({
            schema,
            extensions: source.extensions.stackbit ?? {},
            fieldOptions: source.options.fieldOptions,
          })
          recRemoveUndefinedValues(stackbitConfig)

          const transform = await getTransform(self.transformPath)
          if (transform) {
            stackbitConfig = transform(stackbitConfig)
          }

          const yamlContent = `\
# This file is generated by Contentlayer

${toYamlString(stackbitConfig)}
`

          await fs.writeFile(self.stackbitYamlPath, yamlContent)
          console.log(`Stackbit config generated to ${self.stackbitYamlPath}`)
        },
        (error) => error,
      ),
    ),
  )

const getTransform = async (transformPath: string): Promise<undefined | Transform> => {
  const transformFileExists = await fileOrDirExists(transformPath)
  if (!transformFileExists) {
    return undefined
  }

  const transform = require(transformPath)

  if (typeof transform !== 'function') {
    throw new Error(`Transform file "${transformPath}" doesn't export a function`)
  }

  return transform
}

const fileOrDirExists = async (filePath: string): Promise<boolean> => {
  try {
    const stat = await fs.stat(filePath)
    return stat.isFile() || stat.isDirectory()
  } catch (e: any) {
    return false
  }
}
